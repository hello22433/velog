<p><strong>Part 3. 데이터베이스(DB)</strong>의 첫 문을 여는 <strong>'인덱스(Index)'</strong> 편입니다.</p>
<p>백엔드 개발자가 되어서 가장 처음 마주하는 '성능 이슈'는 90% 확률로 DB 조회 속도 문제입니다. 이때 선배가 &quot;거기 인덱스 걸었어?&quot;라고 물어보는데, 꿀먹은 벙어리가 되면 안 되겠죠?</p>
<p>어려운 B-Tree 구조를 복잡하게 설명하기보다, 가장 직관적인 <strong>'책의 찾아보기(색인)'</strong> 비유로 완벽하게 이해시켜 드립니다.</p>
<hr />
<h2 id="db-책-뒤에-있는-찾아보기가-쿼리-속도를-100배-올린다-인덱스-기초">[DB] 책 뒤에 있는 '찾아보기'가 쿼리 속도를 100배 올린다 (인덱스 기초)</h2>
<h3 id="데이터가-100만-건인데-검색이-3초나-걸려요">&quot;데이터가 100만 건인데, 검색이 3초나 걸려요.&quot;</h3>
<p>쇼핑몰 프로젝트를 하다가 상품 데이터를 100만 개쯤 넣었더니, 상품 검색을 할 때마다 로딩바가 빙글빙글 돕니다.
서버 컴퓨터가 좋지 않아서일까요? 아닙니다.
여러분이 DB에게 <strong>&quot;무식하게 다 뒤져라&quot;</strong>라고 시켰기 때문입니다.</p>
<p>이 느린 거북이 쿼리를 치타로 만드는 마법, <strong>인덱스(Index)</strong>에 대해 알아봅시다.</p>
<hr />
<h3 id="1-인덱스--책의-맨-뒤-찾아보기">1. 인덱스 = 책의 '맨 뒤 찾아보기'</h3>
<p>가장 쉬운 비유는 두꺼운 전공 서적입니다.
여러분이 1,000페이지짜리 책에서 <strong>&quot;자바&quot;</strong>라는 단어를 찾고 싶다고 가정해 봅시다.</p>
<h4 id="상황-a-인덱스가-없을-때-full-table-scan">상황 A: 인덱스가 없을 때 (Full Table Scan)</h4>
<ul>
<li><strong>방법:</strong> 1페이지부터 1,000페이지까지 모든 줄을 읽으면서 &quot;자바&quot;가 있는지 확인합니다.</li>
<li><strong>결과:</strong> 엄청나게 오래 걸립니다. DB 용어로는 <strong>Full Table Scan(풀 테이블 스캔)</strong>이라고 합니다. 최악의 시나리오죠.</li>
</ul>
<h4 id="상황-b-인덱스가-있을-때-index-scan">상황 B: 인덱스가 있을 때 (Index Scan)</h4>
<ul>
<li><strong>방법:</strong> 책의 맨 뒷장 <strong>'색인(찾아보기)'</strong> 페이지를 펼칩니다. 'ㅈ' 항목으로 가서 &quot;자바... 345페이지&quot;를 확인하고, 바로 345페이지를 펼칩니다.</li>
<li><strong>결과:</strong> 0.1초 만에 찾습니다.</li>
</ul>
<p><strong>데이터베이스의 인덱스</strong>도 똑같습니다.
특정 컬럼(예: <code>상품명</code>)을 미리 정렬해서 별도의 메모리 공간(목차)에 저장해 둡니다. 그리고 검색 요청이 오면 원본 테이블을 뒤지는 게 아니라, 이 <strong>목차</strong>를 먼저 뒤져서 위치를 찾아냅니다.</p>
<p><img alt="" src="https://velog.velcdn.com/images/hello22433/post/3c38a8aa-1b5a-4fda-b399-02fd3814c2a7/image.png" /></p>
<hr />
<h3 id="2-그럼-모든-컬럼에-다-걸면-되겠네요-함정-카드">2. &quot;그럼 모든 컬럼에 다 걸면 되겠네요?&quot; (함정 카드)</h3>
<p>인덱스가 이렇게 빠르다면, 이름, 나이, 주소, 성별... 모든 컬럼에 인덱스를 걸어두면 좋지 않을까요?</p>
<p><strong>❌ 절대 안 됩니다.</strong>
인덱스는 공짜가 아닙니다. <strong>'조회 속도'를 얻는 대신 '저장 속도'를 포기하는 거래</strong>이기 때문입니다.</p>
<h4 id="이유-인덱스는-항상-정렬-되어-있어야-한다">이유: 인덱스는 항상 '정렬' 되어 있어야 한다.</h4>
<p>책의 내용이 추가되거나 바뀌면 어떻게 되나요? 맨 뒤의 '찾아보기' 페이지도 다시 고쳐서 가나다순으로 정렬해야 합니다.</p>
<ul>
<li><strong>Insert(삽입):</strong> 새 데이터가 들어오면 인덱스 표를 다시 정렬해야 합니다. (느려짐)</li>
<li><strong>Delete(삭제):</strong> 인덱스 표에서 해당 항목을 지우거나 '사용 안 함' 처리를 해야 합니다.</li>
<li><strong>Update(수정):</strong> 기존 인덱스를 지우고 다시 추가해야 합니다. (가장 부하가 큼)</li>
</ul>
<blockquote>
<p><strong>💡 핵심 요약:</strong>
인덱스는 <strong>읽기(SELECT)</strong> 성능을 비약적으로 높여주지만, <strong>쓰기(INSERT, UPDATE, DELETE)</strong> 성능은 떨어뜨립니다.</p>
</blockquote>
<hr />
<h3 id="3-인덱스-언제-써야-할까요-실무-tip">3. 인덱스, 언제 써야 할까요? (실무 Tip)</h3>
<p>무턱대고 걸지 말고, 아래 기준을 따르세요.</p>
<ol>
<li><strong>데이터 양이 많을 때:</strong> 데이터가 몇 천 건 수준이면 인덱스 없어도 빠릅니다. 최소 수만 건 이상일 때 효과가 큽니다.</li>
<li><strong>조회(SELECT)가 자주 일어나는 컬럼:</strong> <code>WHERE</code> 절에 자주 걸리는 조건(<code>email</code>, <code>user_id</code> 등).</li>
<li><strong>카디널리티(Cardinality, 유니크성)가 높은 컬럼:</strong><ul>
<li><strong>Good:</strong> 주민번호, ID, 전화번호 (중복이 거의 없음 → 검색하면 딱 하나만 나옴)</li>
<li><strong>Bad:</strong> 성별, O/X 여부 (중복이 매우 많음 → 검색해도 데이터의 50%가 나옴. 인덱스 타나 마나 함)</li>
</ul>
</li>
</ol>
<hr />
<h3 id="4-자료구조-맛보기-b-tree">4. 자료구조 맛보기 (B-Tree)</h3>
<p>&quot;DB 인덱스는 어떤 자료구조로 되어 있나요?&quot;라고 묻는다면 <strong>&quot;B-Tree(Balanced Tree)&quot;</strong>라고 대답하면 됩니다.</p>
<ul>
<li>데이터를 순차적으로 리스트에 담는 게 아니라, <strong>트리 구조</strong>로 저장합니다.</li>
<li>덕분에 데이터가 100만 개라도 몇 번의 가지치기(탐색)만으로 원하는 데이터를 찾을 수 있습니다. (시간 복잡도: <code>O(log N)</code>)</li>
</ul>
<hr />
<h3 id="5-실전-면접-대비-3초-요약">5. 실전 면접 대비: 3초 요약</h3>
<p><strong>Q. 인덱스(Index)의 장단점을 설명해주세요.</strong></p>
<blockquote>
<p><strong>A.</strong>
&quot;<strong>장점</strong>은 테이블을 풀 스캔하지 않고 정렬된 트리 구조(B-Tree)를 탐색하므로 <strong>조회(SELECT) 속도가 비약적으로 향상</strong>된다는 점입니다.
반면 <strong>단점</strong>은 데이터를 삽입, 수정, 삭제할 때마다 인덱스도 함께 갱신하고 정렬해야 하므로 <strong>쓰기 성능이 저하</strong>될 수 있고, 추가적인 저장 공간을 차지합니다.&quot;</p>
</blockquote>
<p><strong>Q. 어떤 컬럼에 인덱스를 거는 게 유리한가요?</strong></p>
<blockquote>
<p><strong>A.</strong>
&quot;데이터의 중복도가 낮아 변별력이 높은(<strong>카디널리티가 높은</strong>) 컬럼, 그리고 <code>WHERE</code> 절이나 <code>JOIN</code> 조건으로 자주 사용되는 컬럼에 거는 것이 유리합니다. 반대로 '성별'처럼 중복이 많은 컬럼은 인덱스 효과가 미미합니다.&quot;</p>
</blockquote>
<hr />
<h3 id="🚀-다음-글-예고">🚀 다음 글 예고</h3>
<p>&quot;분명 내 통장에서 돈은 빠져나갔는데, 상대방에게 입금이 안 됐다고?&quot;</p>
<p>상상만 해도 끔찍한 이 상황을 막기 위해 데이터베이스는 <strong>'트랜잭션(Transaction)'</strong>이라는 방어막을 가지고 있습니다.
<strong>&quot;All or Nothing (모 아니면 도)&quot;</strong>의 법칙, ACID에 대해 알아봅시다.</p>
<blockquote>
<p><strong>Next Topic:</strong> [DB] 내 돈이 증발하지 않게 지켜주는 4가지 약속 (트랜잭션과 ACID)</p>
</blockquote>
<hr />