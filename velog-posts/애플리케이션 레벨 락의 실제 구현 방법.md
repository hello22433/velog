<h2 id="초록abstract">초록(Abstract)</h2>
<p>애플리케이션 레벨 락은 여러 요청이 동시에 같은 자원을 수정하려 할 때, 데이터베이스에 접근하기 전에 질서를 세우는 방법이다.
본 글은 애플리케이션 레벨 락을 실제 코드로 어떻게 구현하는지 단계별로 설명하며, 각 단계마다 일상적인 비유를 사용해 초등학생도 이해할 수 있도록 구성한다.</p>
<hr />
<h2 id="1-연구-문제-problem-statement">1. 연구 문제 (Problem Statement)</h2>
<h3 id="11-우리가-막고-싶은-상황">1.1 우리가 막고 싶은 상황</h3>
<p>다음은 실무에서 매우 흔한 상황이다.</p>
<ul>
<li>같은 사용자가 동시에 결제를 시도한다</li>
<li>마지막 재고 1개를 여러 사람이 동시에 구매한다</li>
<li>하루에 한 번만 실행되어야 할 작업이 여러 번 실행된다</li>
</ul>
<p>이 문제의 공통점은:</p>
<blockquote>
<p>“<strong>동시에 하면 안 되는 일</strong>”</p>
</blockquote>
<hr />
<h2 id="2-애플리케이션-락의-핵심-원리">2. 애플리케이션 락의 핵심 원리</h2>
<h3 id="21-한-문장-정의">2.1 한 문장 정의</h3>
<blockquote>
<p>애플리케이션 락은
<strong>중요한 일을 시작하기 전에
‘차례표’를 먼저 받게 하는 규칙</strong>이다.</p>
</blockquote>
<h3 id="22-락의-3요소">2.2 락의 3요소</h3>
<table>
<thead>
<tr>
<th>요소</th>
<th>쉬운 설명</th>
</tr>
</thead>
<tbody><tr>
<td>락 키</td>
<td>무엇에 대한 차례인가</td>
</tr>
<tr>
<td>획득</td>
<td>내가 지금 써도 되는가</td>
</tr>
<tr>
<td>해제</td>
<td>다 썼으니 돌려주기</td>
</tr>
</tbody></table>
<hr />
<h2 id="3-가장-단순한-구현-jvm-내부-락-단일-서버">3. 가장 단순한 구현: JVM 내부 락 (단일 서버)</h2>
<h3 id="31-비유">3.1 비유</h3>
<blockquote>
<p>한 교실에 선생님 한 명
→ 학생들이 선생님 허락 받고 발표</p>
</blockquote>
<hr />
<h3 id="32-코드-예제-synchronized">3.2 코드 예제 (synchronized)</h3>
<pre><code class="language-java">public class CouponService {

    private final Object lock = new Object();

    public void issue() {
        synchronized (lock) {
            if (couponCount &lt;= 0) {
                return;
            }
            couponCount--;
        }
    }
}</code></pre>
<h3 id="33-설명-아주-쉽게">3.3 설명 (아주 쉽게)</h3>
<ul>
<li><p><code>synchronized</code> = “지금 사용 중”</p>
</li>
<li><p>한 명이 들어가면:</p>
<ul>
<li>다른 사람은 밖에서 기다림</li>
</ul>
</li>
<li><p>장점:</p>
<ul>
<li>구현이 매우 쉬움</li>
</ul>
</li>
<li><p>단점:</p>
<ul>
<li>서버가 1대일 때만 가능</li>
</ul>
</li>
</ul>
<hr />
<h2 id="4-서버가-여러-대일-때-분산-애플리케이션-락">4. 서버가 여러 대일 때: 분산 애플리케이션 락</h2>
<h3 id="41-왜-문제가-생길까">4.1 왜 문제가 생길까?</h3>
<ul>
<li>서버 A: “아직 아무도 안 쓰는 중”</li>
<li>서버 B: “나도 안 쓰는 중”</li>
</ul>
<p>둘 다 동시에 시작 → 사고 발생</p>
<hr />
<h2 id="5-redis를-이용한-애플리케이션-락-가장-흔함">5. Redis를 이용한 애플리케이션 락 (가장 흔함)</h2>
<h3 id="51-비유">5.1 비유</h3>
<blockquote>
<p>학교 중앙 게시판에
“지금 이 숙제는 철수가 하고 있음”
이라고 붙여 둔다</p>
</blockquote>
<hr />
<h3 id="52-기본-원리">5.2 기본 원리</h3>
<ol>
<li>Redis에 “사용 중” 표시</li>
<li>있으면 못 들어감</li>
<li>없으면 내가 차지</li>
<li>끝나면 지움</li>
</ol>
<hr />
<h3 id="53-가장-중요한-규칙-논문급-포인트">5.3 가장 중요한 규칙 (논문급 포인트)</h3>
<ul>
<li><strong>원자적이어야 한다</strong></li>
<li><strong>자동으로 풀려야 한다 (TTL)</strong></li>
</ul>
<hr />
<h3 id="54-실제-코드-spring--redis">5.4 실제 코드 (Spring + Redis)</h3>
<pre><code class="language-java">public boolean tryLock(String key) {
    return redisTemplate.opsForValue()
        .setIfAbsent(key, &quot;lock&quot;, Duration.ofSeconds(5));
}</code></pre>
<pre><code class="language-java">public void unlock(String key) {
    redisTemplate.delete(key);
}</code></pre>
<hr />
<h3 id="55-사용하는-서비스-코드">5.5 사용하는 서비스 코드</h3>
<pre><code class="language-java">public void order(Long productId) {
    String lockKey = &quot;lock:product:&quot; + productId;

    if (!tryLock(lockKey)) {
        throw new RuntimeException(&quot;이미 처리 중입니다&quot;);
    }

    try {
        processOrder(productId);
    } finally {
        unlock(lockKey);
    }
}</code></pre>
<hr />
<h3 id="56-초등학생-버전-설명">5.6 초등학생 버전 설명</h3>
<ul>
<li><p>문에 이름표를 붙인다</p>
</li>
<li><p>이미 붙어 있으면:</p>
<ul>
<li>“지금은 안 돼”</li>
</ul>
</li>
<li><p>끝나면:</p>
<ul>
<li>이름표를 뗀다</li>
</ul>
</li>
</ul>
<hr />
<h2 id="6-트랜잭션과-함께-쓰는-구조-중요">6. 트랜잭션과 함께 쓰는 구조 (중요)</h2>
<h3 id="61-올바른-구조">6.1 올바른 구조</h3>
<pre><code class="language-text">[애플리케이션 락 획득]
   ↓
[비즈니스 로직]
   ↓
@Transactional {
   DB 저장
}
   ↓
[락 해제]</code></pre>
<h3 id="62-왜-이렇게-해야-하나">6.2 왜 이렇게 해야 하나?</h3>
<ul>
<li>DB는 결과만 안전하게 저장</li>
<li>락은 순서를 관리</li>
</ul>
<hr />
<h2 id="7-실전-예제-재고-차감">7. 실전 예제: 재고 차감</h2>
<h3 id="71-코드">7.1 코드</h3>
<pre><code class="language-java">public void purchase(Long productId) {
    String key = &quot;lock:product:&quot; + productId;

    if (!lockService.tryLock(key)) {
        throw new IllegalStateException(&quot;이미 구매 중입니다&quot;);
    }

    try {
        stockService.decrease(productId);
    } finally {
        lockService.unlock(key);
    }
}</code></pre>
<pre><code class="language-java">@Transactional
public void decrease(Long productId) {
    Product p = productRepo.findById(productId);
    if (p.stock() &lt;= 0) throw new RuntimeException();
    p.decrease();
}</code></pre>
<hr />
<h2 id="8-실패-상황까지-고려한-설계">8. 실패 상황까지 고려한 설계</h2>
<h3 id="81-서버가-죽으면">8.1 서버가 죽으면?</h3>
<ul>
<li>TTL이 지나면 자동 해제</li>
<li>영원히 잠기지 않음</li>
</ul>
<h3 id="82-중복-해제-방지-고급">8.2 중복 해제 방지 (고급)</h3>
<ul>
<li>락에 UUID 저장</li>
<li>내가 건 락만 풀기</li>
</ul>
<hr />
<h2 id="9-언제-애플리케이션-락을-쓰면-안-되는가">9. 언제 애플리케이션 락을 쓰면 안 되는가?</h2>
<ul>
<li>읽기 전용</li>
<li>경쟁 없음</li>
<li>멱등성 보장</li>
</ul>
<hr />
<h2 id="10-결론">10. 결론</h2>
<blockquote>
<p>애플리케이션 레벨 락은
“DB를 지키기 위한 기술”이 아니라
<strong>“사람의 질서를 코드로 옮긴 규칙”이다.</strong></p>
</blockquote>
<p>코드는 복잡해 보이지만,
실제 생각은 매우 단순하다.</p>
<blockquote>
<p>“지금 이 일은
한 사람만 하자.”</p>
</blockquote>
<hr />
<h2 id="최종-한-줄-요약">최종 한 줄 요약</h2>
<blockquote>
<p><strong>애플리케이션 락 =
중요한 일을 하기 전, 차례를 정하는 코드</strong></p>
</blockquote>