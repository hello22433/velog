<h2 id="질문-배열과-연결리스트의-차이점과-실무에서의-활용">질문: 배열과 연결리스트의 차이점과 실무에서의 활용</h2>
<h3 id="1-기본-차이">1. 기본 차이</h3>
<ul>
<li><p><strong>배열(Array)</strong></p>
<ul>
<li>메모리에 <strong>연속적으로</strong> 데이터를 저장.</li>
<li>인덱스로 바로 접근 가능 → 조회 속도 O(1)</li>
<li>삽입/삭제 시 <strong>중간 요소 이동 필요</strong> → O(n)</li>
<li>메모리 재할당 필요할 수 있음 (동적 배열)</li>
</ul>
</li>
<li><p><strong>연결리스트(Linked List)</strong></p>
<ul>
<li>각 노드가 데이터와 <strong>다음 노드 주소</strong>를 가지고 연결됨.</li>
<li>조회 시 순차 접근 필요 → O(n)</li>
<li>삽입/삭제는 <strong>포인터만 변경</strong>하면 됨 → O(1)</li>
<li>메모리 분산 저장 가능, 크기 가변적</li>
</ul>
</li>
</ul>
<hr />
<h3 id="2-실무에서-배열을-쓰는-이유">2. 실무에서 배열을 쓰는 이유</h3>
<ol>
<li><p><strong>조회가 매우 빈번한 경우</strong></p>
<ul>
<li>예: 대규모 로그 분석, 통계, 머신러닝 벡터/행렬 연산</li>
<li>이유: CPU 캐시 효율이 좋고, 인덱스로 바로 접근 가능</li>
</ul>
</li>
<li><p><strong>데이터 크기가 예측 가능하거나 고정</strong></p>
<ul>
<li>예: 프론트엔드에서 JSON 배열 처리, 서버에서 고정 크 캐시 관리</li>
<li>이유: 배열 재할당 비용이 없고, 메모리 낭비 최소화</li>
</ul>
</li>
<li><p><strong>성능이 중요한 루프/배치 처리</strong></p>
<ul>
<li>예: 게임 엔진에서 매 프레임 업데이트되는 오브젝트 리스트</li>
<li>이유: 연속 메모리 구조는 캐시 미스 최소화 → 반복 작업 최적화</li>
</ul>
</li>
</ol>
<hr />
<h3 id="3-실무에서-연결리스트를-쓰는-이유">3. 실무에서 연결리스트를 쓰는 이유</h3>
<ol>
<li><p><strong>동적 삽입/삭제가 많은 구조</strong></p>
<ul>
<li>예: LRU 캐시, OS 스케줄러, 메모리 프리 블록 관리</li>
<li>이유: 포인터만 바꿔서 노드를 이동/삭제 가능, 데이터 이동 비용 없음</li>
</ul>
</li>
<li><p><strong>데이터 크기가 가변적이거나 알 수 없는 경우</strong></p>
<ul>
<li>예: 실시간 스트리밍 이벤트 처리, 큐/스택 구현</li>
<li>이유: 필요할 때마다 노드 생성 → 메모리 낭비 최소화</li>
</ul>
</li>
<li><p><strong>순차 접근 위주, 중간 삽입/삭제 빈번</strong></p>
<ul>
<li>예: Undo/Redo 기능, 네트워크 패킷 처리 순서 관리</li>
<li>이유: 삽입/삭제 O(1) → 성능 최적화</li>
</ul>
</li>
</ol>
<hr />
<h3 id="4-실무에서-선택할-때-고려할-점">4. 실무에서 선택할 때 고려할 점</h3>
<table>
<thead>
<tr>
<th>항목</th>
<th>배열</th>
<th>연결리스트</th>
</tr>
</thead>
<tbody><tr>
<td>조회 빈도</td>
<td>높음 → 배열 유리</td>
<td>낮음 → 연결리스트 OK</td>
</tr>
<tr>
<td>삽입/삭제 위치</td>
<td>중간 삽입/삭제 빈번 → 비효율</td>
<td>중간 삽입/삭제 많음 → 효율적</td>
</tr>
<tr>
<td>메모리 연속성</td>
<td>중요 → 배열</td>
<td>분산 가능 → 연결리스트</td>
</tr>
<tr>
<td>캐시 효율</td>
<td>중요 → 배열</td>
<td>낮음 → 연결리스트</td>
</tr>
</tbody></table>
<hr />
<h3 id="5-면접-답변용-예시-문단">5. 면접 답변용 예시 문단</h3>
<blockquote>
<p>배열은 연속된 메모리 구조로 인덱스로 바로 접근할 수 있어 조회가 빠르며, 캐시 친화성이 뛰어나서 반복적 데이터 처리, 통계, 머신러닝 벡터 연산 등에 적합합니다. 반대로 연결리스트는 노드 단위로 동적 할당되어 삽입과 삭제가 빈번한 상황에서 효율적이며, LRU 캐시나 OS 프로세스 관리처럼 크기가 가변적이고 순차 접근이 주인 구조에 유리합니다. 따라서 실무에서는 <strong>조회가 많고 크기가 고정</strong>이면 배열, <strong>삽입/삭제가 잦고 크기 가변</strong>이면 연결리스트를 선택하는 것이 일반적입니다.</p>
</blockquote>
<hr />