<h1 id="티켓팅-시스템에서-redis-좌석-홀딩--낙관적-락-조합이-최적의-이유">티켓팅 시스템에서 “Redis 좌석 홀딩 + 낙관적 락” 조합이 최적의 이유</h1>
<h2 id="-비관적-락·분산-락과의-비교를-통한-논리-전개-">— 비관적 락·분산 락과의 비교를 통한 논리 전개 —</h2>
<p>티켓팅 시스템은 일반적인 비즈니스 로직과 다르다.
특정 시점에 수만 명이 같은 좌석을 동시에 선택하는,
<strong>가장 높은 수준의 동시성과 경쟁이 동시에 발생하는 서비스</strong>다.</p>
<p>이런 환경에서는 단순히 “정합성만 보장되는지”가 아니라
<strong>얼마나 빠르게, 얼마나 많은 실패를 감당하며, 전체 시스템을 멈추지 않고 처리할 수 있는지</strong>가 절대적으로 중요하다.</p>
<p>이 관점을 기준으로 보면,
티켓팅에서 가장 많이 사용되는 구조는 다음과 같다.</p>
<ul>
<li><strong>1) Redis 기반 좌석 홀딩 (Seat Hold)</strong></li>
<li><strong>2) 결제 직전 DB의 낙관적 락 적용</strong></li>
<li><strong>3) 낙관적 락 실패 시 짧은 재시도 후 사용자 안내</strong></li>
</ul>
<p>이 조합은 빠르고, 가볍고, 확장 가능하며, 무엇보다 <strong>race condition을 통제하면서도 장애 가능성을 최소화</strong>한다.
아래에서 비관적 락, 분산락 방식과 비교해 그 논리를 확인해보자.</p>
<hr />
<h1 id="1-비관적-락pessimistic-lock의-본질적-한계">1. 비관적 락(Pessimistic Lock)의 본질적 한계</h1>
<p>비관적 락은 데이터를 업데이트하는 순간 row-level로 자물쇠를 거는 방식이다.
정합성은 강력하게 보장하지만 티켓팅 같은 초고객 경쟁 상황에서는 치명적인 단점이 생긴다.</p>
<h3 id="1-lock-contention-→-db-connection-pool-고갈">(1) Lock Contention → DB Connection Pool 고갈</h3>
<p>수만 명이 동시에 좌석을 요청하면
DB는 단 하나의 row에 잡힌 락이 풀릴 때까지
모든 요청을 대기열에 쌓아둔다.</p>
<p>즉,
<strong>경쟁자가 많을수록 시스템 전체가 느려지고, 결국 멈춘다.</strong></p>
<p>→ 대기 요청이 누적
→ DB 스레드/커넥션 풀 소진
→ 서비스 전체 장애로 번짐</p>
<p>티켓팅에서는 지연이 쌓이는 순간 곧바로 대규모 장애가 발생한다.</p>
<h3 id="2-deadlock-발생-가능성-증가">(2) Deadlock 발생 가능성 증가</h3>
<p>여러 좌석을 한번에 구매하는 경우
락을 거는 순서가 뒤섞이면 Deadlock이 발생할 수 있다.</p>
<h3 id="3-수평-확장-불가능">(3) 수평 확장 불가능</h3>
<p>락을 DB가 직접 처리하기 때문에
<strong>DB가 단일 병목지점(Single Point of Contention)</strong> 이 된다.</p>
<hr />
<h1 id="2-분산락redis-redlock-등의-구조적-한계">2. 분산락(Redis RedLock 등)의 구조적 한계</h1>
<p>분산락은 이론적으로는 비관적 락보다 유연하지만
티켓팅처럼 극한 상황에서는 다음과 같은 문제가 생긴다.</p>
<h3 id="1-네트워크-왕복-비용-→-지연-증가">(1) 네트워크 왕복 비용 → 지연 증가</h3>
<p>Redis 락을 잡고 해제하는 과정은
네트워크 왕복이 필수다.</p>
<p>티켓팅에서는 <strong>몇 ms의 지연도 경쟁력을 크게 떨어뜨린다.</strong></p>
<h3 id="2-redis-장애-시-전체-구매-흐름-중단">(2) Redis 장애 시 전체 구매 흐름 중단</h3>
<p>분산락 시스템에서 가장 위험한 상황은
락이 해제되지 않는 경우이다.
Redis 노드 문제가 생기면 티켓팅 전체가 멈출 수 있다.</p>
<h3 id="3-대규모-분산환경에서-병목-현상-발생">(3) 대규모 분산환경에서 병목 현상 발생</h3>
<p>수만 건의 좌석 선택 요청이
하나의 Redis 락 키를 향해 몰리면
락 경쟁은 Redis 차원에서 병목을 만든다.</p>
<p>결국 분산락도 티켓팅 트래픽을 감당하기 어렵다.</p>
<hr />
<h1 id="3-낙관적-락optimistic-lock의-장점">3. 낙관적 락(Optimistic Lock)의 장점</h1>
<p>낙관적 락은 “락을 걸지 않는다”는 점이 핵심이다.
업데이트 시 버전(version)이 변경되었는지만 확인해
변경 충돌을 감지한다.</p>
<p>티켓팅에서는 이 방식이 여러 이유로 적합하다:</p>
<h3 id="1-락이-없으므로-대기열이-없다">(1) 락이 없으므로 대기열이 없다</h3>
<p>락을 잡지 않으므로 DB가 가벼워지고
초고 트래픽에서도 대기열이 발생하지 않는다.</p>
<p>→ 요청이 서로 막지 않는다
→ 실패는 빠르게 감지된다
→ 전체 시스템이 느려지지 않는다</p>
<h3 id="2-충돌-발생을-빠르게-감지">(2) 충돌 발생을 빠르게 감지</h3>
<p>99명이 같은 좌석을 눌러도
버전 mismatch는 즉시 실패한다.</p>
<p><strong>실패 비용이 매우 낮다.</strong></p>
<h3 id="3-수평-확장-가능">(3) 수평 확장 가능</h3>
<p>락 기반이 아니기 때문에
DB 샤딩, 서비스 분리 등이 쉽다.</p>
<hr />
<h1 id="4-그럼-왜-redis-좌석-홀딩과-조합해야-할까">4. 그럼 왜 Redis 좌석 홀딩과 조합해야 할까?</h1>
<p>낙관적 락만으로도 동시성 처리는 가능하지만
<strong>사용자 경험(UX) 측면에서 문제가 생긴다.</strong></p>
<p>좌석 선택 → 결제 단계가 되는 게 아니라
바로 결제 단계에서 “실패”가 너무 많이 발생하기 때문이다.</p>
<p>이를 해결하기 위한 구조가 바로 <strong>Redis 좌석 홀딩</strong>이다.</p>
<h3 id="redis-좌석-홀딩seat-hold의-역할">Redis 좌석 홀딩(Seat Hold)의 역할</h3>
<ul>
<li>좌석을 선택 순간 즉시 “임시 소유권” 부여</li>
<li>2~5분 시간 제한</li>
<li>Redis 메모리에서 처리하므로 속도 1ms 수준</li>
<li>다른 사용자 요청은 즉시 차단 (중복 선택 방지)</li>
</ul>
<p>즉,
<strong>Race Condition 대부분을 DB가 아니라 Redis에서 해결한다.</strong>
DB는 “최종 결제 시점”에만 관여하므로 안정적이다.</p>
<hr />
<h1 id="5-최종-결제-단계에서-낙관적-락을-적용하는-이유">5. 최종 결제 단계에서 낙관적 락을 적용하는 이유</h1>
<p>Redis에서 좌석을 홀드했더라도
결제는 반드시 DB에서 확정해야 한다.</p>
<p>이때 낙관적 락을 적용하면:</p>
<ul>
<li>실제 결제 성공 여부를 정확하게 검증</li>
<li>강한 정합성 유지</li>
<li>실패는 즉시 감지되어 서버 지연 발생 없음</li>
<li>DB 락 경쟁도 없음</li>
</ul>
<p>즉,
<strong>Redis는 속도를, 낙관적 락은 정확도를 맡는다.</strong>
이 두 구조가 합쳐지면
속도와 정확성을 모두 만족하는 완전한 티켓팅 구조가 된다.</p>
<hr />
<h1 id="결론-왜-이-조합이-최선인가">결론: 왜 이 조합이 최선인가?</h1>
<table>
<thead>
<tr>
<th>방식</th>
<th>속도</th>
<th>정합성</th>
<th>확장성</th>
<th>장애 위험</th>
<th>티켓팅 적합도</th>
</tr>
</thead>
<tbody><tr>
<td>비관적 락</td>
<td>매우 낮음</td>
<td>매우 높음</td>
<td>낮음</td>
<td>매우 높음</td>
<td>❌</td>
</tr>
<tr>
<td>분산 락</td>
<td>보통</td>
<td>높음</td>
<td>보통</td>
<td>중간~높음</td>
<td>△</td>
</tr>
<tr>
<td>낙관적 락</td>
<td>매우 높음</td>
<td>중간(충돌 시 실패)</td>
<td>매우 높음</td>
<td>낮음</td>
<td>⭕(결제 단계에 적합)</td>
</tr>
<tr>
<td>Redis 홀딩</td>
<td>최상</td>
<td>낮음(임시 소유권)</td>
<td>최상</td>
<td>낮음</td>
<td>⭕(선택 단계에 최적)</td>
</tr>
<tr>
<td><strong>Redis + 낙관적 락 조합</strong></td>
<td><strong>최상</strong></td>
<td><strong>최상</strong></td>
<td><strong>최상</strong></td>
<td><strong>매우 낮음</strong></td>
<td><strong>최적</strong></td>
</tr>
</tbody></table>
<p>비관적 락과 분산락은 <strong>트래픽이 몰릴수록 시스템 전체가 느려지고, 장애 위험이 증가</strong>한다.
반대로</p>
<p><strong>Redis 좌석 홀딩 + 낙관적 락</strong> 조합은</p>
<ul>
<li>빠르고</li>
<li>충돌을 쉽게 감지하고</li>
<li>대기열을 만들지 않으며</li>
<li>수평 확장 가능하고</li>
<li>장애 위험도 낮다.</li>
</ul>
<p>즉,
<strong>속도와 정합성을 동시에 잡으면서 초고 트래픽을 버틸 수 있는 사실상 유일한 구조</strong>다.</p>