<h2 id="1-19401950년대--컴퓨터와-데이터-그릇의-탄생">1. <strong>1940~1950년대 – 컴퓨터와 데이터 ‘그릇’의 탄생</strong></h2>
<h3 id="상황">상황</h3>
<ul>
<li>컴퓨터가 이제 막 등장했어. ENIAC, UNIVAC 같은 초기 기계들이 등장했지.</li>
<li>문제: <strong>메모리는 극도로 제한적</strong>이고, <strong>CPU 속도도 느림</strong>. 계산해야 할 데이터는 많은데, 하드웨어가 버텨주질 못했어.</li>
</ul>
<h3 id="필요성">필요성</h3>
<ul>
<li>단순히 데이터를 저장하는 것만으로는 부족했어. <strong>데이터를 빠르게 조회하고, 연속적으로 처리할 방법</strong>이 필요했지.</li>
<li>그래서 탄생한 게 <strong>배열(Array)과 스택(Stack)</strong>야.</li>
</ul>
<h3 id="예시">예시</h3>
<ul>
<li>배열 → 한 줄로 번호 매겨진 사물함. 어떤 데이터를 찾으려면 바로 인덱스를 통해 접근 가능.</li>
<li>스택 → 접시 쌓기. 마지막에 올린 접시가 먼저 나가야 하는 상황, 예를 들어 계산기에서 연산 중간값 저장.</li>
</ul>
<p>✅ 핵심: <strong>하드웨어 제약 때문에 효율적 저장과 접근이 필수</strong>였던 시기</p>
<hr />
<h2 id="2-1960년대--고급-언어와-추상화">2. <strong>1960년대 – 고급 언어와 추상화</strong></h2>
<h3 id="상황-1">상황</h3>
<ul>
<li>Fortran, Algol 같은 고급 언어 등장</li>
<li>프로그래머가 <strong>하드웨어 세부 구현에 매몰되지 않고 논리적 문제 해결</strong>에 집중 가능</li>
<li>메모리와 속도는 조금 나아졌지만, 프로그램은 더 커지고 복잡해짐</li>
</ul>
<h3 id="필요성-1">필요성</h3>
<ul>
<li>프로그램이 커지면서 <strong>데이터 관계를 명확하게 표현하고 관리하는 방법</strong> 필요</li>
<li>“순서대로 처리하는 것만으로는 부족해. 큐, 레코드 같은 구조가 필요하다”</li>
<li>데이터 구조를 추상화해야 재사용 가능하고 유지보수가 쉬움</li>
</ul>
<h3 id="예시-1">예시</h3>
<ul>
<li>큐 → 은행 대기 줄. 고객은 들어온 순서대로 처리</li>
<li>레코드 → 학생 정보. 이름, 나이, 학번을 묶어 관리</li>
<li>스택 → 함수 호출 중간 상태 저장</li>
</ul>
<p>✅ 핵심: <strong>하드웨어보다 소프트웨어 문제 해결과 재사용성이 강조된 시기</strong></p>
<hr />
<h2 id="3-19701980년대--알고리즘과-자료구조-황금기">3. <strong>1970~1980년대 – 알고리즘과 자료구조 황금기</strong></h2>
<h3 id="상황-2">상황</h3>
<ul>
<li>컴퓨터 성능은 크게 올라감</li>
<li>하지만 프로그램이 점점 복잡해지고, 데이터 양도 폭발적으로 증가</li>
<li>학계에서는 <strong>자료구조와 알고리즘을 수학적, 이론적으로 정립</strong>하기 시작함</li>
</ul>
<h3 id="필요성-2">필요성</h3>
<ul>
<li>단순 배열과 스택만으로는 복잡한 문제를 해결할 수 없었음</li>
<li>“데이터 간 관계를 표현하고, 최적화된 탐색·삽입·삭제 방법이 필요하다”</li>
<li><strong>트리, 그래프, 해시</strong> 등장</li>
</ul>
<h3 id="예시-2">예시</h3>
<ul>
<li>트리 → 회사 조직도. 계층 구조를 효율적으로 표현</li>
<li>그래프 → 지하철 노선도. 노드와 간선으로 복잡한 연결 관계 표현</li>
<li>해시 → 사물함 열쇠. 키를 통해 데이터를 즉시 찾음</li>
</ul>
<p>✅ 핵심: <strong>대규모 데이터와 복잡한 관계를 효율적으로 처리하기 위해 발전</strong></p>
<hr />
<h2 id="4-1990년대-이후--객체지향과-인터넷-시대">4. <strong>1990년대 이후 – 객체지향과 인터넷 시대</strong></h2>
<h3 id="상황-3">상황</h3>
<ul>
<li>인터넷과 웹 서비스 폭발적 증가</li>
<li>대규모 데이터 처리, DB, 캐시, 메시지 큐 등 현실 문제 등장</li>
<li>객체지향 언어(Java, C++)로 <strong>자료구조와 프로그램 설계를 통합</strong></li>
</ul>
<h3 id="필요성-3">필요성</h3>
<ul>
<li>단순히 데이터를 저장하는 것만으로는 부족</li>
<li>현실 시스템에서 <strong>대규모 트래픽, 실시간 처리, 데이터 일관성, 최적화</strong> 필요</li>
<li>자료구조가 <strong>실제 서비스 설계와 직접 연결</strong>되기 시작</li>
</ul>
<h3 id="예시-3">예시</h3>
<ul>
<li>B-Tree → DB 인덱스, 원하는 책을 빠르게 찾기 위해 계층 구조</li>
<li>LRU 캐시 → 브라우저 최근 페이지, 오래된 페이지 제거</li>
<li>메시지 큐 → 택배 센터, 먼저 들어온 물건 먼저 처리</li>
</ul>
<p>✅ 핵심: <strong>현실 세계 시스템 문제를 해결하기 위해 자료구조가 필수적인 설계 도구가 됨</strong></p>
<hr />
<h3 id="🔹-정리">🔹 정리</h3>
<table>
<thead>
<tr>
<th>시대</th>
<th>필요성</th>
<th>자료구조 발전</th>
</tr>
</thead>
<tbody><tr>
<td>1940~50</td>
<td>메모리와 속도 제약 극복</td>
<td>배열, 스택</td>
</tr>
<tr>
<td>1960</td>
<td>프로그램 추상화, 재사용</td>
<td>큐, 레코드, 스택 확장</td>
</tr>
<tr>
<td>1970~80</td>
<td>대규모 데이터·복잡한 관계 처리</td>
<td>트리, 그래프, 해시</td>
</tr>
<tr>
<td>1990~</td>
<td>대규모 서비스·실시간 시스템</td>
<td>B-Tree, LRU 캐시, 메시지 큐, 분산 자료구조</td>
</tr>
</tbody></table>
<ul>
<li><strong>요약하면</strong>:
자료구조는 <strong>하드웨어 제약 → 소프트웨어 추상화 → 복잡한 데이터 처리 → 현실 시스템 문제 해결</strong> 순으로 발전했어.
즉, 역사 자체가 “문제를 효율적으로 해결하기 위한 도구”라는 점이 핵심이야.</li>
</ul>
<hr />