<h2 id="🧠-1️⃣-메모리-관리란">🧠 1️⃣ 메모리 관리란?</h2>
<blockquote>
<p><strong>CPU가 실행할 프로그램을 메모리에 어떻게 배치하고, 관리할 것인가</strong>를 다루는 부분</p>
</blockquote>
<p>운영체제(OS)는 여러 프로그램이 동시에 실행될 때
각 프로그램이 <strong>서로의 메모리를 침범하지 않게 하면서</strong>,
<strong>효율적으로 메모리를 분배</strong>해야 합니다.</p>
<hr />
<h2 id="⚙️-2️⃣-기본-개념-주소-공간address-space">⚙️ 2️⃣ 기본 개념: 주소 공간(Address Space)</h2>
<table>
<thead>
<tr>
<th>용어</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td><strong>물리 주소 (Physical Address)</strong></td>
<td>실제 RAM(하드웨어) 상의 주소</td>
</tr>
<tr>
<td><strong>논리 주소 (Logical / Virtual Address)</strong></td>
<td>CPU가 보는 주소 (프로세스 입장에서의 주소)</td>
</tr>
</tbody></table>
<p>CPU는 항상 <strong>논리 주소(Virtual Address)</strong> 를 사용합니다.
운영체제와 MMU(Memory Management Unit)가 이를 <strong>물리 주소</strong>로 변환합니다.</p>
<p>이 과정을 <strong>주소 변환(Address Translation)</strong> 이라고 합니다.</p>
<hr />
<h2 id="🧩-3️⃣-주소-변환의-핵심-mmu-memory-management-unit">🧩 3️⃣ 주소 변환의 핵심: MMU (Memory Management Unit)</h2>
<p>MMU는 CPU와 메모리 사이에서
“논리 주소 → 물리 주소” 변환을 자동으로 수행합니다.</p>
<p>예:</p>
<pre><code>프로세스 A 입장: 0x0000 → 실제 RAM: 0x3F00  
프로세스 B 입장: 0x0000 → 실제 RAM: 0x7B00</code></pre><p>→ 각 프로세스는 자기만의 0x0000을 갖지만,
MMU가 매핑을 다르게 해서 서로 충돌하지 않게 해줍니다.</p>
<hr />
<h2 id="🧩-4️⃣-메모리-관리-기법의-발전-과정">🧩 4️⃣ 메모리 관리 기법의 발전 과정</h2>
<p>운영체제가 메모리를 관리하는 방식은 아래 순서대로 발전했습니다:</p>
<table>
<thead>
<tr>
<th>세대</th>
<th>방식</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>①</td>
<td><strong>단일 연속 할당 (Single Contiguous Allocation)</strong></td>
<td>하나의 프로그램만 실행</td>
</tr>
<tr>
<td>②</td>
<td><strong>고정 분할 (Fixed Partition)</strong></td>
<td>메모리를 일정 크기로 나눔 (비효율적)</td>
</tr>
<tr>
<td>③</td>
<td><strong>가변 분할 (Dynamic Partition)</strong></td>
<td>필요한 만큼만 할당 (외부 단편화 문제)</td>
</tr>
<tr>
<td>④</td>
<td><strong>페이징 (Paging)</strong></td>
<td>메모리를 고정 크기 블록으로 분리</td>
</tr>
<tr>
<td>⑤</td>
<td><strong>세그먼테이션 (Segmentation)</strong></td>
<td>논리적 단위(함수, 배열 등)로 나눔</td>
</tr>
<tr>
<td>⑥</td>
<td><strong>가상 메모리 (Virtual Memory)</strong></td>
<td>실제 메모리보다 큰 공간처럼 사용</td>
</tr>
</tbody></table>
<hr />
<h2 id="📦-5️⃣-페이징-paging">📦 5️⃣ 페이징 (Paging)</h2>
<blockquote>
<p>메모리를 <strong>고정된 크기(Page)</strong> 로 나누어 관리하는 방식</p>
</blockquote>
<h3 id="기본-원리">기본 원리</h3>
<ul>
<li><strong>논리 메모리</strong>: 일정 크기의 <strong>페이지(Page)</strong> 로 나눔</li>
<li><strong>물리 메모리(RAM)</strong>: 동일 크기의 <strong>프레임(Frame)</strong> 으로 나눔</li>
<li><strong>페이지 테이블(Page Table)</strong>: 각 페이지가 어떤 프레임에 들어있는지 저장</li>
</ul>
<pre><code>프로세스의 페이지 0 → 물리 메모리 프레임 3  
프로세스의 페이지 1 → 프레임 5</code></pre><p>💡 <strong>장점:</strong> 외부 단편화(External Fragmentation) 해결
💡 <strong>단점:</strong> 내부 단편화(Internal Fragmentation) 발생 가능</p>
<hr />
<h3 id="🔍-단편화fragmentation">🔍 단편화(Fragmentation)</h3>
<table>
<thead>
<tr>
<th>종류</th>
<th>설명</th>
<th>예시</th>
</tr>
</thead>
<tbody><tr>
<td><strong>외부 단편화</strong></td>
<td>빈 공간이 여기저기 흩어져 합치면 크지만, 연속 공간이 부족한 경우</td>
<td>가변 분할 방식에서 발생</td>
</tr>
<tr>
<td><strong>내부 단편화</strong></td>
<td>페이지 단위로 나누다 남는 공간 낭비</td>
<td>페이징 방식에서 발생</td>
</tr>
</tbody></table>
<hr />
<h2 id="🧩-6️⃣-세그먼테이션-segmentation">🧩 6️⃣ 세그먼테이션 (Segmentation)</h2>
<blockquote>
<p>프로그램을 논리적 단위(코드, 데이터, 스택 등)로 나누어 관리</p>
</blockquote>
<ul>
<li>각 세그먼트는 길이가 다를 수 있음 (가변 크기)</li>
<li>세그먼트마다 <strong>세그먼트 번호 + 오프셋(offset)</strong> 으로 접근</li>
<li><strong>논리 구조를 반영</strong>하므로, 프로그래머 입장에서는 더 직관적</li>
</ul>
<p>📌 <strong>단점:</strong> 가변 크기 때문에 외부 단편화 발생 가능
📌 그래서 보통 “페이징 + 세그먼테이션”을 결합해 사용합니다.</p>
<hr />
<h2 id="🧩-7️⃣-가상-메모리-virtual-memory">🧩 7️⃣ 가상 메모리 (Virtual Memory)</h2>
<blockquote>
<p><strong>물리적 메모리보다 더 큰 주소 공간을 사용할 수 있게 해주는 기술</strong></p>
</blockquote>
<p>운영체제가 <strong>디스크 일부를 RAM처럼 사용</strong>해서
실제로는 없는 메모리 공간을 “가상으로 확장”합니다.</p>
<h3 id="핵심-메커니즘-demand-paging">핵심 메커니즘: <strong>Demand Paging</strong></h3>
<ul>
<li>필요한 페이지만 메모리에 올림</li>
<li>나머지는 디스크(스왑 영역)에 저장</li>
<li>접근할 때 없으면 → <strong>Page Fault</strong> 발생 → 디스크에서 불러옴</li>
</ul>
<hr />
<h2 id="⚡️-8️⃣-페이지-폴트-page-fault">⚡️ 8️⃣ 페이지 폴트 (Page Fault)</h2>
<blockquote>
<p>CPU가 접근하려는 페이지가 메모리에 없을 때 발생하는 인터럽트</p>
</blockquote>
<ol>
<li>CPU가 페이지에 접근</li>
<li>MMU가 페이지 테이블을 확인 → 없으면 Page Fault</li>
<li>OS가 디스크에서 해당 페이지를 가져와 RAM에 로드</li>
<li>페이지 테이블 갱신 후 재실행</li>
</ol>
<p>📌 페이지 폴트는 느리지만, 가상 메모리의 핵심 메커니즘입니다.</p>
<hr />
<h2 id="🧠-9️⃣-스와핑swapping">🧠 9️⃣ 스와핑(Swapping)</h2>
<blockquote>
<p>전체 프로세스(또는 일부 페이지)를 디스크로 내보내거나(RAM 확보), 다시 불러오는 것</p>
</blockquote>
<ul>
<li><strong>swap out:</strong> 메모리가 부족할 때 프로세스를 디스크로 내보냄</li>
<li><strong>swap in:</strong> 다시 실행해야 할 때 디스크에서 불러옴</li>
</ul>
<p>💡 이 과정은 <strong>디스크 I/O 비용</strong>이 매우 커서 자주 일어나면 성능 저하.</p>
<hr />
<h2 id="💬-10️⃣-면접-질문-요약">💬 10️⃣ 면접 질문 요약</h2>
<table>
<thead>
<tr>
<th>질문</th>
<th>답변 핵심</th>
</tr>
</thead>
<tbody><tr>
<td>Q. 물리 주소와 논리 주소의 차이는?</td>
<td>물리 주소는 실제 RAM 주소, 논리 주소는 CPU가 보는 가상 주소</td>
</tr>
<tr>
<td>Q. 페이징의 장단점은?</td>
<td>외부 단편화 해결, 내부 단편화 가능</td>
</tr>
<tr>
<td>Q. 세그먼테이션이란?</td>
<td>코드, 데이터 등 논리 단위로 나누는 메모리 관리 기법</td>
</tr>
<tr>
<td>Q. 가상 메모리란?</td>
<td>디스크 일부를 메모리처럼 사용해 실제보다 큰 공간을 제공</td>
</tr>
<tr>
<td>Q. 페이지 폴트란?</td>
<td>필요한 페이지가 메모리에 없을 때 발생하는 인터럽트</td>
</tr>
<tr>
<td>Q. 스와핑이란?</td>
<td>프로세스를 디스크와 메모리 간에 교체하는 과정</td>
</tr>
</tbody></table>
<hr />
<h2 id="💡-핵심-한-줄-요약">💡 핵심 한 줄 요약</h2>
<blockquote>
<p><strong>페이징은 고정 크기, 세그먼테이션은 논리 단위</strong>,
<strong>가상 메모리는 둘을 결합하여 실제보다 큰 메모리처럼 사용하는 기술</strong>이다.</p>
</blockquote>
<hr />