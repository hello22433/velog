<hr />
<h1 id="퀵정렬quick-sort-완벽-이해-개념부터-구현까지">퀵정렬(Quick Sort) 완벽 이해: 개념부터 구현까지</h1>
<p>정렬 알고리즘은 컴퓨터과학에서 가장 기본적이면서도 중요한 주제 중 하나입니다. 그중에서도 <strong>퀵정렬(Quick Sort)</strong>은 평균적으로 매우 빠른 성능을 보여 실제로 자주 사용되는 정렬 알고리즘입니다. 이번 글에서는 퀵정렬의 개념, 동작 원리, 시간복잡도, 장단점, 그리고 자바스크립트 구현까지 모두 살펴보겠습니다.</p>
<hr />
<h2 id="1-퀵정렬quick-sort란">1. 퀵정렬(Quick Sort)란?</h2>
<p>퀵정렬은 <strong>분할 정복(Divide and Conquer)</strong> 방법을 사용하는 정렬 알고리즘입니다.
간단히 말하면:</p>
<ol>
<li>리스트에서 <strong>하나의 기준 값(pivot)</strong>을 선택합니다.</li>
<li>기준 값보다 작은 값들은 왼쪽, 큰 값들은 오른쪽으로 <strong>분할(partition)</strong> 합니다.</li>
<li>분할된 왼쪽과 오른쪽 리스트에 대해 <strong>재귀적으로</strong> 퀵정렬을 수행합니다.</li>
<li>더 이상 나눌 수 없을 때, 모든 부분 리스트를 합쳐 최종 정렬 결과를 얻습니다.</li>
</ol>
<p>퀵정렬은 <strong>제자리 정렬(in-place sort)</strong>이 가능하지만, 구현 방식에 따라 추가 배열을 사용하는 경우도 있습니다.</p>
<hr />
<h2 id="2-퀵정렬-동작-예시">2. 퀵정렬 동작 예시</h2>
<p>예를 들어 <code>[3, 6, 2, 7, 5]</code>를 정렬한다고 해봅시다.</p>
<ol>
<li><p><strong>기준 값 선택</strong>: 5를 pivot으로 선택</p>
</li>
<li><p><strong>분할(partition)</strong>:</p>
<ul>
<li>왼쪽: <code>[3, 2]</code> (5보다 작은 값)</li>
<li>기준값: <code>[5]</code></li>
<li>오른쪽: <code>[6, 7]</code> (5보다 큰 값)</li>
</ul>
</li>
<li><p><strong>왼쪽 재귀 호출</strong>: <code>[3, 2]</code> → pivot = 2 → <code>[2], [3]</code></p>
</li>
<li><p><strong>오른쪽 재귀 호출</strong>: <code>[6, 7]</code> → pivot = 7 → <code>[6], [7]</code></p>
</li>
<li><p><strong>합치기</strong>: <code>[2, 3, 5, 6, 7]</code></p>
</li>
</ol>
<p>이 과정을 통해 원래 배열이 정렬됩니다.</p>
<hr />
<h2 id="3-퀵정렬-시간-복잡도">3. 퀵정렬 시간 복잡도</h2>
<p>퀵정렬은 선택한 pivot에 따라 성능이 달라집니다.</p>
<table>
<thead>
<tr>
<th>경우</th>
<th>시간복잡도</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>평균</td>
<td>O(n log n)</td>
<td>pivot이 적절하게 분할될 때</td>
</tr>
<tr>
<td>최악</td>
<td>O(n²)</td>
<td>pivot이 매번 최솟값이나 최댓값일 때</td>
</tr>
<tr>
<td>최선</td>
<td>O(n log n)</td>
<td>pivot이 항상 중앙값일 때</td>
</tr>
</tbody></table>
<p><strong>공간복잡도</strong>는 재귀 호출 때문에 O(log n)입니다(제자리 정렬 기준).</p>
<hr />
<h2 id="4-퀵정렬-장단점">4. 퀵정렬 장단점</h2>
<h3 id="장점">장점</h3>
<ul>
<li>평균적으로 매우 빠른 정렬 알고리즘</li>
<li>메모리 사용이 효율적(제자리 정렬 가능)</li>
<li>분할 정복 구조로 이해하기 쉬움</li>
</ul>
<h3 id="단점">단점</h3>
<ul>
<li>최악의 경우 O(n²) 발생</li>
<li>안정 정렬(stable sort)이 아님 → 동일한 값의 상대적 순서 보장 X</li>
<li>재귀 호출로 인해 스택 오버플로우 가능 (리스트가 매우 길 경우)</li>
</ul>
<hr />
<h2 id="5-퀵정렬-구현-javascript-예제">5. 퀵정렬 구현 (JavaScript 예제)</h2>
<pre><code class="language-javascript">function quickSort(arr) {
  if (arr.length &lt;= 1) return arr; // 더 이상 나눌 수 없으면 반환

  const pivot = arr[arr.length - 1]; // 마지막 원소를 pivot으로 선택
  const left = [];
  const right = [];

  for (let i = 0; i &lt; arr.length - 1; i++) {
    if (arr[i] &lt; pivot) left.push(arr[i]);
    else right.push(arr[i]);
  }

  return [...quickSort(left), pivot, ...quickSort(right)];
}

// 테스트
const nums = [3, 6, 2, 7, 5];
console.log(quickSort(nums)); // [2, 3, 5, 6, 7]</code></pre>
<blockquote>
<p>위 코드는 간단하고 직관적이지만, 추가 배열을 사용하기 때문에 제자리 정렬이 아닙니다.
제자리 정렬을 위해서는 배열 내부에서 <strong>swap</strong>을 이용한 partition 방식이 필요합니다.</p>
</blockquote>
<hr />
<h2 id="6-마무리">6. 마무리</h2>
<p>퀵정렬은 <strong>빠른 평균 성능</strong>과 <strong>분할 정복 구조</strong> 덕분에 실제 현업에서도 자주 사용되는 정렬 알고리즘입니다.
단, pivot 선택에 따라 성능 차이가 크므로, 실무에서는 <strong>랜덤 pivot 선택</strong>이나 <strong>3중 중앙값(Median-of-Three)</strong> 방식을 사용해 최악의 경우를 피하는 전략을 씁니다.</p>
<hr />
<p>퀵정렬을 완전히 이해하면 <strong>재귀 구조, 분할 정복, 배열 조작</strong>을 모두 학습할 수 있어, 다른 알고리즘 공부에도 큰 도움이 됩니다.</p>
<hr />