<h2 id="📚-목차-table-of-contents">📚 목차 (Table of Contents)</h2>
<h3 id="프롤로그-왜-개발자가-돈의-흐름economics을-알아야-하는가">프롤로그: 왜 개발자가 돈의 흐름(Economics)을 알아야 하는가?</h3>
<ul>
<li>경제학도가 코드를 치게 된 이유 (비전공자의 시선)</li>
<li>비트코인의 가격이 아닌 '시스템'에 주목하다</li>
<li>이 책(시리즈)에서 만들 최종 결과물 아키텍처 미리보기</li>
</ul>
<h3 id="part-1-도메인-설계-거래소는-어떻게-돌아가는가-domain--design">Part 1. 도메인 설계: 거래소는 어떻게 돌아가는가? (Domain &amp; Design)</h3>
<blockquote>
<p><strong>핵심:</strong> 경제학적 지식을 개발 용어로 번역하는 단계. DDD(도메인 주도 설계) 관점 적용.</p>
</blockquote>
<ul>
<li><strong>Chapter 1. 호가창(Order Book)의 해부학</strong><ul>
<li>매수(Bid)와 매도(Ask)의 스프레드 이해</li>
<li>자바 객체로 모델링하는 호가 데이터 (Order Class 설계)</li>
</ul>
</li>
<li><strong>Chapter 2. 돈은 실수(Float)가 아니다: 정밀도 문제</strong><ul>
<li>금융 시스템에서 <code>double</code>을 쓰면 망하는 이유 (부동소수점 오류)</li>
<li><code>BigDecimal</code>을 활용한 정확한 자산 계산 로직</li>
</ul>
</li>
<li><strong>Chapter 3. 거래의 수명 주기 (Lifecycle)</strong><ul>
<li>주문 접수 -&gt; 대기 -&gt; 체결 -&gt; 정산의 상태 전이 다이어그램</li>
<li>상태 패턴(State Pattern)을 적용한 주문 관리</li>
</ul>
</li>
</ul>
<h3 id="part-2-핵심-엔진-구현-초당-수만-건의-트래픽-견디기-core-engineering">Part 2. 핵심 엔진 구현: 초당 수만 건의 트래픽 견디기 (Core Engineering)</h3>
<blockquote>
<p><strong>핵심:</strong> 자바 백엔드의 기술적 깊이를 보여주는 파트. 동시성 제어와 성능 최적화.</p>
</blockquote>
<ul>
<li><strong>Chapter 4. 체결 엔진(Matching Engine) 만들기</strong><ul>
<li>DB로 매칭하면 느리다: 메모리 기반 매칭 알고리즘</li>
<li>선입선출(FIFO) 큐를 활용한 주문 우선순위 처리</li>
</ul>
</li>
<li><strong>Chapter 5. 동시성 이슈와의 전쟁</strong><ul>
<li>&quot;내 돈이 두 번 출금됐어요&quot;: Race Condition 방지 전략</li>
<li>비관적 락(Pessimistic Lock) vs 낙관적 락(Optimistic Lock) 적용기</li>
<li>Redis를 활용한 분산 락(Distributed Lock) 구현</li>
</ul>
</li>
<li><strong>Chapter 6. 이벤트 기반 아키텍처 (Event-Driven)</strong><ul>
<li>체결이 완료되면 일어나는 일들 (알림, 지갑 업데이트, 차트 갱신)</li>
<li>Kafka(또는 RabbitMQ)를 이용한 서비스 간 결합도 낮추기</li>
</ul>
</li>
</ul>
<h3 id="part-3-데이터와-성능-실시간성의-미학-data--performance">Part 3. 데이터와 성능: 실시간성의 미학 (Data &amp; Performance)</h3>
<blockquote>
<p><strong>핵심:</strong> 대용량 데이터 처리와 네트워크 최적화 기술 어필.</p>
</blockquote>
<ul>
<li><strong>Chapter 7. 1초도 늦으면 안 된다: 실시간 시세 전송</strong><ul>
<li>HTTP Polling의 한계와 WebSocket 도입</li>
<li>Netty 기반의 고성능 소켓 서버 튜닝 (Spring WebFlux 찍먹하기)</li>
</ul>
</li>
<li><strong>Chapter 8. 캔들 차트(OHLCV) 데이터 관리</strong><ul>
<li>초봉, 분봉, 일봉 데이터 집계 전략</li>
<li>시계열 데이터베이스(TSDB) 맛보기 혹은 RDB 파티셔닝 전략</li>
</ul>
</li>
<li><strong>Chapter 9. 대장애의 시대: 서킷 브레이커와 안정성</strong><ul>
<li>외부 API(업비트/바이낸스) 장애 시 내 시스템을 보호하는 법 (Resilience4j)</li>
</ul>
</li>
</ul>
<h3 id="part-4-확장-나만의-퀀트-비서-application">Part 4. 확장: 나만의 퀀트 비서 (Application)</h3>
<blockquote>
<p><strong>핵심:</strong> 흥미 유발 및 실제 사용 가능한 서비스로 확장.</p>
</blockquote>
<ul>
<li><strong>Chapter 10. 지표를 코드로: 기술적 분석 구현</strong><ul>
<li>RSI, 볼린저 밴드 알고리즘 직접 구현해보기 (라이브러리 없이)</li>
</ul>
</li>
<li><strong>Chapter 11. 24시간 잠들지 않는 봇(Bot)</strong><ul>
<li>전략 패턴(Strategy Pattern)을 이용한 매매 전략 갈아끼우기</li>
<li>백테스팅(Backtesting) 시뮬레이터 구현: 과거 데이터로 내 로직 검증하기</li>
</ul>
</li>
</ul>
<h3 id="에필로그-시스템을-넘어">에필로그: 시스템을 넘어</h3>
<ul>
<li>프로젝트를 하며 배운 것들 (기술적 부채와 해결 과정)</li>
<li>백엔드 개발자로서 핀테크 시장을 바라보는 시선</li>
<li>앞으로의 로드맵 (클라우드 배포, MSA 전환 등)</li>
</ul>
<hr />