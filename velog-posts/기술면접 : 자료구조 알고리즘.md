<p><strong>Q1. 배열과 연결리스트의 차이점은 무엇인가?</strong>
<strong>A1.</strong></p>
<ul>
<li><p><strong>배열(Array)</strong></p>
<ul>
<li>메모리 상에 연속적으로 데이터를 저장.</li>
<li>인덱스로 바로 접근 가능(O(1)).</li>
<li>삽입/삭제 시 전체 요소를 이동해야 해서 비효율적(O(n)).</li>
</ul>
</li>
<li><p><strong>연결리스트(Linked List)</strong></p>
<ul>
<li>각 노드가 데이터와 다음 노드의 포인터를 저장, 메모리가 연속적일 필요 없음.</li>
<li>특정 위치 접근은 처음부터 순차 탐색 필요(O(n)).</li>
<li>삽입/삭제가 효율적(O(1)), 포인터 추가로 메모리 사용량 증가.</li>
</ul>
</li>
<li><p><strong>사용 사례</strong></p>
<ul>
<li>배열: 랜덤 접근이 필요한 경우, 정적 데이터 처리</li>
<li>연결리스트: 삽입/삭제가 빈번한 경우, 큐나 스택 구현</li>
</ul>
</li>
</ul>
<p><strong>Q2. 스택과 큐의 차이점과 사용 사례는 무엇인가?</strong>
<strong>A2.</strong></p>
<ul>
<li><p><strong>스택(Stack)</strong>: LIFO 구조, 마지막에 넣은 데이터가 먼저 나감.</p>
<ul>
<li>사용 사례: 함수 호출 스택, Undo/Redo 기능.</li>
</ul>
</li>
<li><p><strong>큐(Queue)</strong>: FIFO 구조, 먼저 넣은 데이터가 먼저 나감.</p>
<ul>
<li>사용 사례: 작업 스케줄링, 메시지 처리 시스템.</li>
</ul>
</li>
</ul>
<p><strong>Q3. 해시 테이블(Hash Table)의 장점과 단점은 무엇인가?</strong>
<strong>A3.</strong></p>
<ul>
<li>장점: 평균적으로 O(1) 조회/삽입 가능, 키 기반 데이터 접근 효율적.</li>
<li>단점: 충돌 처리 필요(Chaining, Open Addressing), 메모리 사용량 증가 가능.</li>
<li>사용 사례: 캐시 구현, 빈도수 계산, 중복 제거.</li>
</ul>
<p><strong>Q4. 단일 연결리스트와 이중 연결리스트의 차이점은 무엇인가요?</strong>
<strong>A4.</strong></p>
<ul>
<li><p><strong>단일 연결리스트(Singly Linked List)</strong>: 각 노드가 다음 노드의 포인터만 가짐.</p>
<ul>
<li>장점: 메모리 절약, 구현 단순</li>
<li>단점: 역방향 탐색 불가, 삭제 시 이전 노드 접근 필요</li>
</ul>
</li>
<li><p><strong>이중 연결리스트(Doubly Linked List)</strong>: 각 노드가 이전 노드와 다음 노드 포인터를 모두 가짐.</p>
<ul>
<li>장점: 양방향 탐색 가능, 삭제가 편리</li>
<li>단점: 포인터 추가로 메모리 사용량 증가, 구현 복잡</li>
</ul>
</li>
</ul>
<p><strong>Q5. 트리(Tree)와 이진 트리(Binary Tree)의 차이점은 무엇인가요?</strong>
<strong>A5.</strong></p>
<ul>
<li><p><strong>트리(Tree)</strong>: 노드와 계층 구조를 가진 일반 자료구조, 부모-자식 관계</p>
</li>
<li><p><strong>이진 트리(Binary Tree)</strong>: 각 노드가 최대 두 개의 자식을 가짐</p>
<ul>
<li>장점: 균형 트리(BST) 사용 시 탐색, 삽입, 삭제 효율적(O(log n))</li>
<li>용도: 계층 구조 표현, 검색, 정렬</li>
</ul>
</li>
</ul>
<p><strong>Q6. 이진 탐색(Binary Search)과 선형 탐색(Linear Search)의 차이점은 무엇인가요?</strong>
<strong>A6.</strong></p>
<ul>
<li><strong>선형 탐색</strong>: 배열/리스트 처음부터 끝까지 순차적으로 탐색, O(n)</li>
<li><strong>이진 탐색</strong>: 정렬된 배열에서 중간 값과 비교, 탐색 범위 절반으로 줄임, O(log n)</li>
<li><strong>조건</strong>: 이진 탐색은 반드시 정렬된 자료에서만 가능</li>
</ul>
<p><strong>Q7. 스택을 활용하는 대표적인 알고리즘 문제는 무엇이 있나요?</strong>
<strong>A7.</strong></p>
<ul>
<li>괄호 짝 맞추기: <code>()</code>, <code>{}</code>, <code>[]</code> 균형 확인</li>
<li>DFS(Depth-First Search) 구현 시 재귀 대신 스택 사용 가능</li>
<li>Undo/Redo 기능 구현</li>
</ul>
<p><strong>Q8. 큐를 활용하는 대표적인 알고리즘 문제는 무엇이 있나요?</strong>
<strong>A8.</strong></p>
<ul>
<li>BFS(Breadth-First Search) 탐색 구현</li>
<li>작업 스케줄링 문제, 메시지 처리, 프린터 작업 순서</li>
<li>슬라이딩 윈도우 최대/최소 문제</li>
</ul>
<p><strong>Q9. 해시 테이블을 사용하면 어떤 문제가 해결되나요?</strong>
<strong>A9.</strong></p>
<ul>
<li>중복 데이터 제거, 빈도수 계산 문제</li>
<li>특정 값 존재 여부 빠른 체크(O(1))</li>
<li>캐시, 매핑 구조 구현</li>
</ul>
<p><strong>Q10. 우선순위 큐(Priority Queue)란 무엇인가요?</strong>
<strong>A10.</strong></p>
<ul>
<li>큐지만 각 요소가 우선순위를 가짐</li>
<li>높은 우선순위 요소부터 제거/처리</li>
<li>일반적으로 힙(Heap)으로 구현</li>
<li>사용 사례: 다익스트라 최단 경로 알고리즘, 작업 스케줄링</li>
</ul>
<hr />